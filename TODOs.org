* Chip8 Todo List
** configure ncurses

** timer!!!
** display fps in curses???
*** calculate fps

* Display
** display function: does it xor propertly? Surely only xor if it only appears on the screen??? If it already exists. Otherwie a straight collision == setting an image
  // N.B These individual BITS from the mem[I] location should get put to display.
  // So we should do something funky with >>2, >>3, >>4, etc... to isolate the bits.


* Debug mode:
** TODO create disassembler
*** Add more 'comments'  / pseudo-assembly code to each opcode
** TODO decent 'step through' logging.


* Command line arguments to accept:
** DONE ./chip8 roms/pong
   CLOSED: [2016-07-26 Tue 23:50]
** ./chip8 roms/pong --io ncurses -o pong.asm
** ./chip8 roms/pong --disassemble -o pong.asm
** ./chip8 roms/pong --disassemble --output pong.asm
** ./chip8 roms/pong --version
** ./chip8 roms/pong --help

*
todo - for next iteration

Assembler: asm -> bytecode
Disassembler: bytecode -> asm
Interpreter: bytecode -> running program.



can all 3 use the same loop?
Eg. a simple 0x00E0 => whatever instruction?

No. Assembler must be different. Surely??
Hang on:
Can have enum of 36 'instructions'
enum bytecode_instruction {
00EE,
etc..
}
and
a 2 way map (?) bytecode_instruction => instruction || instruction => bytecode_instruction


one function just has a solid map:
"EXYN": "LOAD VX XY"

one function reverses this:
"LOAD VX XY": "EXYN"

 But: difference between interpretation (letting the bytecode tell us to loop and looping) and just assembling... eg. Just printing 'jump 29')

 - TODO: relative jumping??? ??????? / loading, etc..

Then we'd have to do a regex-type thing for both codes:
Also, we'd have to ensure that the interpretation is fast (we wouldn't care really about assembler / disassembler..).


input file => from cli
output file => from cli / default

void assemble {
}

void disassemble {
}

void interpret {
}

========================================
typedef enum opcode {
00EE
Fnnn
...
} opcode


typedef struct opcode_t {
opcode_t opcode;
char[4] bytecode;
char[MAX_INSTRUCTION_SIZE] instruction;
}


# typedef
# struct _opcode_and_type {
# opcode opcode;
# opcode_type opcode_type;
# } opcode_and_type

# stuct opcode_t
# {nnn => }
2 steps??
bytecode -> `opcode` (enum)
instruction -> `opcode`

can be one operation?: {
`opcode` -> instruction
`opcode` -> bytecode
`opcode` -> running instruction????
}
-----> could be used to create 3 different main functions??? Preprocessor: #ifdef INST etc...
               ./chip8, ./chip8asm, ./chip8disasm
====> Can we have one single main function which has 3 different functions which have been generated by proprocessor??????
chip8.o, chip8ams.o, chip8disasm.o??
Seems like the best option

disassembler:
bytecode -> instruction

interpreter:
bytecode -> run instructions (kind of...)

assembler:
instruction -> bytecode

1 - convert 'F123' to enum Fnnn. Simple map?
                 opcode_t bytecode_to_opcode(char *string) {
                 opcode_t opcode;
                 strcpy(opcode.string_opcode, string)
                 switch((string & 0xF000) >> 8){
                 case('F'):
                   Fnnn
                 break;
                 ...
                 }
                 }

2 - lookup enum against




---------------------------------------------------------------------------
disassembler:
bytecode -> instruction

interpreter:
bytecode -> run instructions (kind of...)

assembler:
instruction -> bytecode
---------------------------------------------------------------------------

typedef struct opcode_t {
opcode enum;
char* bytecode;
char* instruction;
}

can be one operation?: {
`opcode` -> instruction
`opcode` -> bytecode
`opcode` -> running instruction????
}
-----> could be used to create 3 different main functions??? Preprocessor: #ifdef INST etc...
               ./chip8, ./chip8asm, ./chip8disasm
====> Can we have one single main function which has 3 different functions which have been generated by proprocessor??????
chip8.o, chip8ams.o, chip8disasm.o??
Seems like the best option


if(opcode.enum == FXYZ)
{
#ifdef INSTRUCTION
// assume that opcode.instruction doesn't exist. We're _CALCULATING_
// so we have to use bytecode.
opcode.instruction = XYZ_instruction("JMP", opcode);
#endif // INSTRUCTION

#ifdef BYTECODE
// assume that opcode.bytecode doesn't exist. We're _CALCULATING_
// so we have to use instruction.
opcode.bytecode = XYZ_bytecode("F", opcode);
?? enum to_s?? then replace xxx or nnn
#endif // BYTECODE

#ifdef RUN_INSTRUCTIN
v[x] = v[y];
#endif
}

char* XYZ_bytecode(char first, opcode_t opcode){
=============> should return a NUMBER!
char bytecode[4];
bytecode[0] = first;
//             ?           "LOAD V[x] V[y]"
//                          012345678
# uint8_t z = 0x000000000F & opcode.instruction >> 64;
uint8_t z = opcode.instruction[7];
bytecode[2] = x;
return bytecode;
const char *hexstring = "0xabcdef0";
int number = (int)strtol(hexstring, NULL, 0);
strtol
}

char* XYZ_instruction(char* input_char, opcode) {
char* return_char = malloc((sizeof(input_char) + 10 )* sizeof(char));
memcpy(return_char, input_char);
uint8_t z = 0xF & opcode.bytecode
memcpy(return_char + sizeof(inputchar), " V[X] V[Y]);
return return_char;
}

opcode_t JMP(opcode_t opcode){
{
#ifdef INSTRUCTION
// assume that opcode.instruction doesn't exist. We're _CALCULATING_
// so we have to use bytecode.
#endif // INSTRUCTION
#ifdef BYTECODE
... etc..
}
???????
==> actually could be tricky.. Cos we'd have to define a whole load of instructions. Let's just create really good tests & refactor from haviing a megalist.












00E0 - CLS
00EE - RET
0nnn - SYS addr
1nnn - JP addr
2nnn - CALL addr
3xkk - SE Vx, byte
4xkk - SNE Vx, byte
5xy0 - SE Vx, Vy
6xkk - LD Vx, byte
7xkk - ADD Vx, byte
8xy0 - LD Vx, Vy
8xy1 - OR Vx, Vy
8xy2 - AND Vx, Vy
8xy3 - XOR Vx, Vy
8xy4 - ADD Vx, Vy
8xy5 - SUB Vx, Vy
8xy6 - SHR Vx {, Vy}
8xy7 - SUBN Vx, Vy
8xyE - SHL Vx {, Vy}
9xy0 - SNE Vx, Vy
Annn - LD I, addr
Bnnn - JP V0, addr
Cxkk - RND Vx, byte
Dxyn - DRW Vx, Vy, nibble
Ex9E - SKP Vx
ExA1 - SKNP Vx
Fx07 - LD Vx, DT
Fx0A - LD Vx, K
Fx15 - LD DT, Vx
Fx18 - LD ST, Vx
Fx1E - ADD I, Vx
Fx29 - LD F, Vx
Fx33 - LD B, Vx
Fx55 - LD [I], Vx
Fx65 - LD Vx, [I]















ADD I, Vx - Fx1E
ADD Vx, Vy - 8xy4
ADD Vx, byte - 7xkk

AND Vx, Vy - 8xy2

CALL addr - 2nnn

CLS - 00E0 RET - 00EE

DRW Vx, Vy, nibble - Dxyn

JP V0, addr - Bnnn
JP addr - 1nnn

LD B, Vx - Fx33
LD DT, Vx - Fx15
LD F, Vx - Fx29
LD I, addr - Annn
LD ST, Vx - Fx18
LD Vx, DT - Fx07
LD Vx, K - Fx0A
LD Vx, Vy - 8xy0
LD Vx, [I] - Fx65
LD Vx, byte - 6xkk
LD [I], Vx - Fx55

OR Vx, Vy - 8xy1

RND Vx, byte - Cxkk

SE Vx, Vy - 5xy0
SE Vx, byte - 3xkk

SHL Vx {, Vy} - 8xyE

SHR Vx {, Vy} - 8xy6

SKNP Vx - ExA1

SKP Vx - Ex9E

SNE Vx, Vy - 9xy0
SNE Vx, byte - 4xkk

SUB Vx, Vy - 8xy5

SUBN Vx, Vy - 8xy7

SYS addr - 0nnn

XOR Vx, Vy - 8xy3

----------------------------------------------
2 steps??
bytecode -> `opcode` (enum)
instruction -> `opcode`

can be one operation?: {
`opcode` -> instruction
`opcode` -> bytecode
`opcode` -> running instruction????
}

=====> We should use function pointers.
Eg return function pointer.
BUT - to what?

typedef enum{
assemble
disassemble
interpret
} state


*update state based on user input / defaults*

case(FNNN):
{
if(state == assemble)
ret
}
